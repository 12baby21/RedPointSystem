---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wujunfei.
--- DateTime: 2025/5/21 15:23
--- 提供对外接口
--- Singleton
---


---@class RedPointManager
local RedPointManager = {}
RedPointManager.__index = RedPointManager

---@type RedPointTree
local RedPointTree = require("redPoint.RedPointTree")
---@type LuaUtils
local LuaUtils = require("redPoint.LuaUtils")

local RedPointManager = class("RedPointManager")

local _instance = nil
function RedPointManager:getInstance()
    if _instance == nil then
        _instance = setmetatable({}, RedPointManager)
        _instance:init()
    end
    return _instance
end

function RedPointManager:ctor()
    -- 给任何对象添加事件监听和派发能力（不必继承 Node）
    -- cc(self):addComponent("components.behavior.EventProtocol"):exportMethods()
    -- cc(self):addComponent("app.components.Notification"):exportMethods()
    self:init()
    self.eventManager = require("redPoint.RedPointEventManager"):getInstance()
    -- cc(self):addComponent("components.behavior.EventProtocol"):exportMethods()
    -- self.netEngine = app:netEngine()
end

function RedPointManager:init()
    ---@type RedPointTree[]
    self.redPointForest = {}            -- 红点森林，方便管理孤立结点，key为根节点红点id
    ---@type table<string, table<string, RedPointStruct>>
    self.eventObserverMap = {}          -- 事件观察者，通过事件触发红点，key为事件string，每次数据来都要处理的
    ---@type table<string, RedPointNode>
    self.redPointNodeMap = {}

end

---tryRegisterToParent 尝试注册到父红点上，支持动态注册，但是需要保证红点id唯一
function RedPointManager:tryRegisterToParent(params)
    ---@type RedPointTree
    local childTree = nil       -- 子红点树
    ---@type RedPointTree
    local parentTree = nil      -- 父红点所在的红点树

    --- 1. 若存在，找到父红点和子红点树
    for _, redPointTree in pairs(self.redPointForest) do
        if redPointTree:hasRedPointStruct(params.id) then
            childTree = redPointTree
        end
        if redPointTree:hasRedPointStruct(params.parentId) then
            parentTree = redPointTree
        end
    end
    if childTree and parentTree then
        -- 如果都存在，则需要判断是否是相同的树
        -- 如果是相同的树，结构已经确定了，只需要更新即可
        -- 如果不是相同的树，需要把子树挂到父红点所在的树上
        if not self:isSameTree(childTree, parentTree) then
            local parentStruct = parentTree:getRedPointStructById(params.parentId)
            local childStruct = childTree:getRedPointStructById(params.id)
            parentStruct:addChild(childStruct)
            childStruct:setUpdateFunc(params.funcMap)
            self.redPointForest[childTree.rootId] = nil     -- 移除子树
        end
    elseif not childTree and not parentTree then
        -- 红点树不存在：创建一棵新树
        local parentId = params.parentId and params.parentId ~= "" and params.parentId or nil 
        local idString = params.id
        if params.parentId then
            idString = table.concat({params.parentId, "|", idString})
        end
        local tree = RedPointTree.new({
            idString = idString,
            funcMap = params.funcMap,
        })
        self.redPointForest[tree.root.id] = tree
        local redPointStruct = tree:getRedPointStructById(params.id)
        for redPointType, func in pairs(params.funcMap or {}) do
            local triggerEvents = func.events
            self:updateEventObserver(redPointStruct, triggerEvents, redPointType)
        end
    else
        local tree = childTree or parentTree
        -- 如果只有子红点树，需要重构红点树和红点森林的映射
        local changeParams = tree:tryRegisterToParent(params)
        if changeParams.isRootChanged then
            self.redPointForest[changeParams.newRootId] = tree
            self.redPointForest[changeParams.oldRootId] = nil
        end
        local redPointStruct = tree:getRedPointStructById(params.id)
        for redPointType, func in pairs(params.funcMap or {}) do
            local triggerEvents = func.events
            self:updateEventObserver(redPointStruct, triggerEvents, redPointType)
        end
    end    
end

---register 通过完整的红点路径注册
function RedPointManager:registerWithFullPath(params)
    local idString = params.idString
    local ids = LuaUtils.splitString(idString, "|")
    local rootId = ids[1]
    if self.redPointForest[rootId] == nil then
        --- 没有这颗树，直接构造一颗新的红点树
        self.redPointForest[rootId] = RedPointTree.new({
            id = rootId,
            funcMap = params.funcMap,
        })
    end
    local redPointTree = self.redPointForest[rootId]
    local redPointStruct = self.redPointForest[rootId]:getRedPointStruct(ids[#ids])
    for redPointType, func in pairs(params.funcMap or {}) do
        local triggerEvents = func.events
        self:updateEventObserver(redPointStruct, triggerEvents, redPointType)
    end
end

---updateEventObserver 订阅事件
function RedPointManager:updateEventObserver(observer, events, redPointType)
    for _, event in ipairs(events or {}) do
        if not self.eventObserverMap[event] then
            self.eventObserverMap[event] = {}
            self.eventManager:addEventListener(event, handler(self, self.onReceiveEvent))
        end
        local eventObserver = self.eventObserverMap[event]
        eventObserver[observer:getId()] = {
            redPointStruct = observer,
            redPointType = redPointType,
        }
    end
end

---bind @必须手动绑定
---@param uiRedPoint node @红点UI
---@param id string @id是逻辑红点唯一id
function RedPointManager:bind(uiRedPoint, id)
    local redPointStruct = self:getRedPointStructById(id)
    if redPointStruct then
        local list = self.redPointNodeMap[id] or {}
        list[#list + 1] = uiRedPoint
        self.redPointNodeMap[id] = list
    else
        printInfo(string.format("There is no logic red point with id: %s", id))
        return false
    end
end

---unbind 红点Node onExit时会自动执行，无需手动调用
function RedPointManager:unbind(redPointUI, id)
    local observerUiList = self.redPointNodeMap[id]
    if observerUiList then
        local index = table.indexof(observerUiList, redPointUI)
        if index then
            table.remove(observerUiList, index)
        end
    end
end

---unBindAllById 离开界面时移除逻辑红点id对应的所有红点node
---这个方法是为了解决同一个id绑定的过多，一个个移除性能太低，使用时需要明确业务需求
function RedPointManager:unBindAllById(id)
    self.redPointNodeMap[id] = nil
end

function RedPointManager:unregister(idString)
    local ids = LuaUtils.splitString(idString, "|")
    local redPointStruct = self:getRedPointStruct(idString)
    if not redPointStruct then
        dump(ids, "删除失败，没有找到当前层级结构的红点：")
        return
    end
    --- 删除事件观察者
    local events = redPointStruct:getTriggerEvents()
    for _, event in ipairs(events) do
        local eventObserver = self.eventObserverMap[event]
        eventObserver[redPointStruct:getId()] = nil
    end

    --- 从红点树上移除
    local redPointTree = self.redPointForest[ids[1]]
    if redPointTree then
        -- todo 直接从父结点删除
        redPointTree:unregister()
    end
end

---removeTree 删除整颗树
function RedPointManager:removeTree(rootId)
    if self.redPointForest[rootId] then
        self.redPointForest[rootId] = nil
    end

end

---getRedPointStruct 获取逻辑红点
---@param idString string
---@return RedPointStruct
function RedPointManager:getRedPointStruct(idString)
    local ids = LuaUtils.splitString(idString, "|")
    local rootId = ids[1]       -- todo: 是否需要改成字符串？
    local redPointTree = self.redPointForest[rootId]
    if rootId == 0 or not redPointTree then
        printError(string.format("没有找到路径为%s的红点树不存在", idString))
        return nil
    end

    return redPointTree:getRedPointStructById(ids[#ids])
end

---getRedPointStructById 通过唯一红点id获取红点（尽量不要使用）
function RedPointManager:getRedPointStructById(id)
    for _, redPointTree in pairs(self.redPointForest) do
        local redPointStruct = redPointTree:getRedPointStructById(id)
        if redPointStruct then
            return redPointStruct
        end
    end
    return nil
end



function RedPointManager:onReceiveEvent(event, ...)
    --- 1. 收到刷新的事件
    --- 2. 找到对应的逻辑红点进行脏标设置
    --- 3. 找到受影响的红点UI进行实际的计算
    local eventName = event.name
    local eventObserver = self.eventObserverMap[eventName] or {}
    for _, observer in pairs(eventObserver) do
        local redPointStruct = observer.redPointStruct
        local idString = redPointStruct:getIdString()       -- todo
        -- 事件触发时，没有办法知道影响的红点类型，只能全部设置脏标，除非在红点构造时就知道事件对应哪个红点类型
        -- 但这确实也是一种可以的做法，不这么做就全部设置脏标
        redPointStruct:setDirty(true, observer.redPointType)
        self:updateShow(redPointStruct)
    end
end

--- 刷新UI显示，通过唯一id找相关的UI
function RedPointManager:updateShow(redPointStruct)
    while redPointStruct do
        local id = redPointStruct.id
        local observerUiList = self.redPointNodeMap[id] or {}
        for _, observerUI in ipairs(observerUiList) do
            local customData = observerUI:getCustomData()
            local showType, showNum = redPointStruct:getShowInfo(customData)
            observerUI:updateShow(showType, showNum)
        end
        redPointStruct = redPointStruct.parent
    end
end

function RedPointManager:forceUpdateRedPoint(redPointNode)
    local customData = redPointNode:getCustomData()
    local redPointStruct = self:getRedPointStruct(redPointNode.idString)
    local showType, showNum = redPointStruct:getShowInfo("EVENT_FORCE_UPDATE_RED_POINT", customData)
    redPointNode:updateShow(showType, showNum)
end

---isSameTree 根相同就认为是同一棵树
function RedPointManager:isSameTree(tree1, tree2)
    return tree1 and tree2 and tree1.rootId == tree2.rootId
end

---getIdStringById 根据逻辑红点id获取完整路径
function RedPointManager:getIdStringById(id)
    local redPointStruct = self:getRedPointStructById(id)
    return redPointStruct and redPointStruct:getIdString() or ""
end

------------------------------------------- EVENT -------------------------------------------
function RedPointManager:addEventListener(eventName, callback)
    self.eventManager:addEventListener(eventName, callback)
end

function RedPointManager:dispatchEvent(params)
    self.eventManager:dispatchEvent(params)
end



return RedPointManager