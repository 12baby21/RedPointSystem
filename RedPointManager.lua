---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wujunfei.
--- DateTime: 2025/5/21 15:23
--- 提供对外接口
--- Singleton
---

---@class RedPointManager
local RedPointManager = {}
RedPointManager.__index = RedPointManager

---@type RedPointTree
local RedPointTree = require("redPoint.RedPointTree")
---@type LuaUtils
local LuaUtils = require("redPoint.LuaUtils")

local _instance = nil
function RedPointManager:getInstance()
    if _instance == nil then
        _instance = setmetatable({}, RedPointManager)
        _instance:init()
    end
    return _instance
end

function RedPointManager:init()
    ---@type RedPointTree[]
    self.redPointForest = {}            -- 红点森林，方便管理孤立结点，key为根节点红点id
    ---@type RedPointStruct[][]
    self.eventObserverMap = {}          -- 事件观察者，通过事件触发红点，key为事件string，每次数据来都要处理的
    ---@type table<string, RedPointNode>
    self.redPointNodeMap = {}
end

---tryRegisterToParent 尝试注册到父红点上，支持动态注册，但是需要保证红点id唯一
function RedPointManager:tryRegisterToParent(params)
    ---@type RedPointTree
    local childTree = nil       -- 子红点树
    ---@type RedPointTree
    local parentTree = nil      -- 父红点所在的红点树

    --- 1. 若存在，找到父红点和子红点树
    for _, redPointTree in pairs(self.redPointForest) do
        if redPointTree:hasRedPointStruct(params.id) then
            childTree = redPointTree
        end
        if redPointTree:hasRedPointStruct(params.parentId) then
            parentTree = redPointTree
        end
    end
    if childTree and parentTree then
        -- 如果都存在，则需要判断是否是相同的树
        -- 如果是相同的树，结构已经确定了，只需要更新即可
        -- 如果不是相同的树，需要把子树挂到父红点所在的树上
        if not self:isSameTree(childTree, parentTree) then
            local parentStruct = parentTree:getRedPointStructById(params.parentId)
            local childStruct = childTree:getRedPointStructById(params.id)
            parentStruct:addChild(childStruct)
            childStruct:setUpdateFunc(params.funcMap)
            self.redPointForest[childTree.rootId] = nil     -- 移除子树
        end
    elseif not childTree and not parentTree then
        -- 红点树不存在：创建一棵新树
        tree = RedPointTree.new({
            idString = table.concat({ params.parentId, "|", params.id })
        })
        self.redPointForest[params.parentId] = tree
    else
        local tree = childTree or parentTree
        -- 只有子树，需要一个父红点
        local changeParams = tree:tryRegisterToParent(params)
        if changeParams.isRootChanged then
            self.redPointForest[changeParams.newRootId] = tree
            self.redPointForest[changeParams.oldRootId] = nil
        end
    end
end

---register 通过完整的红点路径注册     todo:注册完成后移除子红点树
function RedPointManager:register(redPointParams)
    local ids = LuaUtils.splitString(redPointParams.idString, "|")
    local rootId = checkint(ids[1])
    local insertResult = false          -- 插入成功才需要
    if self.redPointForest[rootId] == nil then
        --- 没有这颗树，直接构造一颗新的红点树
        self.redPointForest[rootId] = RedPointTree.new(redPointParams)
        insertResult = true
    else
        local redPointTree = self.redPointForest[rootId]
        insertResult = redPointTree:insertNode(ids)
    end
    local redPointStruct = self.redPointForest[rootId]:getRedPointStruct(checkint(ids[#ids]))
    local triggerEvents = redPointParams.events
    for _, event in ipairs(triggerEvents) do
        if not self.eventObserverMap[event] then
            self.eventObserverMap[event] = {}
        end
        local eventObserver = self.eventObserverMap[event]
        eventObserver[redPointStruct:getId()] = redPointStruct
    end
end

function RedPointManager:registerToParent(parentId, redId)
    if not parentId or parentId == 0 then
        dump(string.format("无法注册父红点id为%d的红点", parentId))
        return
    end
    assert(redId and redId > 0, "红点id有误")
    local parentNode = self:getRedPointNodeById(parentId)
    if parentNode then
        local parentIdString = parentNode:getIdString()
        local idString = table.concat({parentIdString, "|", redId})
        self:register({
            idString = idString,
        })
    end
end

function RedPointManager:isSameTree(tree1, tree2)
    return tree1 and tree2 and tree1.rootId == tree2.rootId

end

function RedPointManager:unregister(idString)
    local ids = LuaUtils.splitString(idString, "|")
    local redPointStruct = self:getRedPointStruct(idString)
    if not redPointStruct then
        dump(ids, "删除失败，没有找到当前层级结构的红点：")
        return
    end
    --- 删除事件观察者
    local events = redPointStruct:getTriggerEvents()
    for _, event in ipairs(events) do
        local eventObserver = self.eventObserverMap[event]
        eventObserver[redPointStruct:getId()] = nil
    end

    --- 从红点树上移除
    local redPointTree = self.redPointForest[checkint(ids[1])]
    if redPointTree then
        -- todo 直接从父结点删除
        redPointTree:unregister()
    end
end

---removeTree 删除整颗树
function RedPointManager:removeTree(rootId)
    if self.redPointForest[rootId] then
        self.redPointForest[rootId] = nil
    end

end

---getRedPointStruct 获取逻辑红点
---@param idString string
---@return RedPointStruct
function RedPointManager:getRedPointStruct(idString)
    local ids = LuaUtils.splitString(idString, "|")
    local rootId = checkint(ids[1])
    local redPointTree = self.redPointForest[rootId]
    if rootId == 0 or not redPointTree then
        printError(string.format("没有找到路径为%s的红点树不存在", idString))
        return nil
    end

    return redPointTree:getRedPointStructById(ids[#ids])
end

---getRedPointNodeById 通过唯一红点id获取红点（尽量不要使用）
function RedPointManager:getRedPointNodeById(id)
    for _, redPointTree in pairs(self.redPointForest) do
        local redPointStruct = redPointTree:getRedPointNodeById(id)
        if redPointStruct then
            return redPointStruct
        end
    end
    return nil
end

--- 进入界面时绑定红点ui(完整路径注册)
function RedPointManager:bind(uiRedPoint, idString)
    local redPointNode = self:getRedPointStruct(idString)
    if redPointNode then
        local list = self.redPointNodeMap[idString] or {}
        local bindKey = tostring(#list + 1)
        list[bindKey] = uiRedPoint
        self.redPointNodeMap[idString] = list
        return true
    else
        dump("没有相应的逻辑红点")
        return false
    end
end

--- 离开界面时移除红点ui todo延迟移除
function RedPointManager:unbind(idString, redPointUI)
    local observerUiList = self.redPointNodeMap[idString]
    table.remove(observerUiList, redPointUI)
end

function RedPointManager:onReceiveEvent(event, ...)
    --- 1. 收到刷新的事件
    --- 2. 找到对应的逻辑红点进行脏标设置
    --- 3. 找到受影响的红点UI进行实际的计算
    local eventObserver = self.eventObserverMap[event] or {}
    for _, observer in ipairs(eventObserver) do
        local idString = observer:getIdString()
        -- 事件触发时，没有办法知道影响的红点类型，只能全部设置脏标，除非在红点构造时就知道事件对应哪个红点类型
        -- 但这确实也是一种可以的做法，不这么做就全部设置脏标
        observer:setDirty(true)
        local observerUiList = self.redPointNodeMap[idString] or {}
        for _, observerUI in ipairs(observerUiList) do
            local customData = observerUI:getCustomData()
            local showType, showNum = observer:getShowInfo(customData)
            observerUI:updateShow(showType, showNum)
        end
    end
end

------------------------------------------- TEST -------------------------------------------



return RedPointManager