# 红点系统综述



## 红点的结构

红点主要分为以下两种结构：

### 1. 树型红点

这种红点主要符合游戏的界面层级结构，子红点的显示逻辑独立，同一层级的子红点以或关系影响父红点的显示（穿透）。

### 2. 独立红点

这种红点主要用于一些不穿透的独立红点，它们的显示不会影响上一级界面。



## 红点的类型

### 1. new红点

一般用于新功能开启或者获得新道具时，消失方式为点击后消失，客户端存储点击状态。

### 2. 普通红点

最常见的红点，一般用于玩法可玩、道具可用或其他策划希望玩家点击的功能，点击不会消失，需要满足一定条件（如没有使用次数等）后消失，更新方式一般是玩家操作后的服务器消息回调。

### 3. 数字红点

一般用于玩法次数有限，提示玩家需要消耗，每次使用后数字红点会减少1，剩余次数为0红点消失。

### 4. 自定义红点

为一些玩法特设的红点，逻辑可能和以上任意一种相同，但是表现不同。比如，策划可以要求有新的道具到包使用绿色感叹号，或者有新任务使用黄色感叹（逻辑同2）号。



# 红点系统结构

## 1. `RedPointManager`

整个红点系统由`RedPointManager`统一管理，提供对外接口来管理红点。`RedPointManager`主要包含三部分：红点森林、红点`UI`的`Map`和事件观察者（`eventObserver`）。这样设计的主要目的，是可以把逻辑、`UI`和事件相互隔离，避免耦合。

为什么采用红点森林？

因为在开发过程中，可能会遇到策划需要红点不进行穿透（自定义红点穿透），这种情况下，子红点的显示就不应该影响父红点的显示。红点森林包含多棵红点树，每棵红点树作为一个独立的结构进行逻辑管理。

红点`UI`如何关联到逻辑红点？

1. 在业务逻辑开发中，红点`UI`通过`id`绑定到逻辑红点。
2. 事件到来时，事件观察者找到事件对应的逻辑红点。
3. 逻辑红点进行刷新，并设置红点`UI`的显示。

红点`UI`的绑定时机？

在进入红点所在界面的时候进行绑定，在离开该界面需要对红点进行解绑。

## 2. `RedPointManager`

红点树实现为一棵字典树，通过红点层级结构进行建树，如果层级路径上有逻辑红点尚未定义，也会递归地进行生成。

红点树向`RedPointManager`提供接口来注册和删除红点，同时保存红点`id`到`RedPointStruct`的映射



## 3. `RedPointStruct`

每一个红点是否都需要有刷新方法？

叶子红点必须有刷新方法，否则没有意义。非叶红点可以没有刷新方法（通过子红点来进行刷新）。当非叶红点有刷新方法时，需要确定刷新方法的优先级。

```pseudocode
RedPointStruct {
	required number id					// 红点唯一id
	required string idString			// 红点层级字符串：描述在字典树中的路径
	
}
```





# 需要明确的需求

父红点的显示类型的决定因素：

1. 唯一确定的（比如，即使子红点是数字红点，但父红点仍然显示为红点）
2. 由子红点决定（这种情况下子红点和父红点的显示类型应当一致）
3. 由显示优先级决定（可拓展性高，多个点亮的子红点可以根据显示优先级影响父红点的显示）

父红点是否需要红点条件：应该是需要的，需要思考一种管理方式

红点结构的生成方式：

1. 预先配置生成。策划预先定义好红点结构，客户端注册逻辑红点结构.
2. 客户端在代码编写过程中自行注册，需要妥善管理好树型结构（注册到树中、注册到父红点）
   直接注册到父红点中需要判断父红点是否存在（通过红点唯一Id判断）

# 性能优化

延迟刷新

当事件触发时，只有红点`UI`有效的红点才进行逻辑刷新，否则只设置脏标。