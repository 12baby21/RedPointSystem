# 红点系统综述



## 红点的结构

红点主要分为以下两种结构：

**树型红点**

这类红点主要符合游戏的界面层级结构，子红点的显示逻辑独立，同一层级的子红点以或关系影响父红点的显示（穿透）。

**独立红点**

这类红点主要用于一些不穿透的独立红点，它们的显示不会影响上一级界面。



## 红点的显示类型

**new红点**

一般用于新功能开启或者获得新道具时，消失方式为点击后消失，客户端存储点击状态。

**普通红点**

最常见的红点，一般用于玩法可玩、道具可用或其他策划希望玩家点击的功能，点击不会消失，需要满足一定条件（如没有使用次数等）后消失，更新方式一般是玩家操作后的服务器消息回调。

**数字红点**

一般用于玩法次数有限，提示玩家需要消耗，每次使用后数字红点会减少1，剩余次数为0红点消失。

**自定义红点**

为一些玩法特设的红点，逻辑可能和以上任意一种相同，但是表现不同。比如，策划可以要求有新的道具到包使用绿色感叹号，或者有新任务使用黄色感叹号（逻辑同普通红点）。



# 红点系统设计

## 1. `RedPointManager`

整个红点系统由`RedPointManager`统一管理，提供对外接口来管理红点。`RedPointManager`主要包含三部分：红点森林、红点`UI`的`Map`和事件观察者（`eventObserver`）。这样设计的主要目的，是可以把逻辑、`UI`和事件相互隔离，避免耦合。

**为什么采用红点森林？**

因为在开发过程中，可能会遇到策划需要红点不进行穿透（自定义红点穿透），这种情况下，子红点的显示就不应该影响父红点的显示。红点森林包含多棵红点树，每棵红点树作为一个独立的结构进行逻辑管理。

**红点`UI`如何关联到逻辑红点？**

1. 在业务逻辑开发中，红点`UI`通过`id`绑定到逻辑红点。
2. 事件到来时，事件观察者找到事件对应的逻辑红点。
3. 逻辑红点进行刷新，并设置红点`UI`的显示。

**红点`UI`的绑定时机？**

在进入红点所在界面的时候进行绑定，在离开该界面需要对红点进行解绑。

**红点`UI`的刷新流程？**

1. 事件通知`RedPointManager`，`RedPointManager`在森林中找到相应的`RedPointTree`，然后找到对应的那个红点
2. 向根节点设置脏标，逻辑上，但不进行逻辑判断
3. 如果该红点`UI`注册在`RedPointManager`中，则调用对应红点的刷新方法（向叶子红点递归地计算红点），刷新红点的显示，重置脏标

**如果是其中的某个非叶子结点需要刷新该怎么处理？**

先判断自身的刷新函数，本身为`true`则不再对子红点进行遍历，脏标设置为false：
情况①：子红点又因为事件发生了变化，则该红点仍然会被设置脏标；
情况②：该红点因为事件改变，本身需要设置脏标；
优先级不会产生问题，因为是通过红点map进行管理的，所以不同类型的红点会有独立的脏标
问题1：在何时进行优先级判断
暂时考虑在`UI`刷新中，根据该红点注册的红点类型，按优先级判断，所以在`RedPointStruct:isShow()`中只对某个类型的显示与否进行判断。
问题2：`customData`怎么处理?
留给刷新方法自己获取

## 2. `RedPointTree`

### 简介

<img src="./图片/红点树_字典树架构.png" alt="红点树_字典树架构" style="zoom:50%;" />

上图为以字典树实现的红点树的逻辑层级结构，通过红点的路径（如`MAIN|BAG|ITEM_1`）可以快速索引到具体的`RedPointStruct`。由于每一个红点`id`是唯一的，因此红点路径（`idString`）也是唯一的。同时又可以通过`id`快速检索到具体对应的是哪个功能，为业务开发提供了较大的可扩展性。

### 构造红点树

构造红点树的流程相当于在红点树上新增子红点。一般来说应该从根开始建立，因为在红点树中保存了红点`id`到`RedPointStruct`的映射，所以可以从**叶子到根**进行构造。这样做的好处在于，1.可以避免遍历从根向下进行遍历（尽管事件复杂度为`log(n)`）；2.可以把直接添加红点到父红点和建树逻辑统一。

从叶子到根流程如下：

1.通过 `idString`（如 `"main|task|daily"`）从 **叶子到根** 依次构造节点；

2.如果某一层节点已存在，则说明已经构建完；

3.自动建立父子关系；

4.设置叶子节点的 `updateFunc`；

5.如果尚未设置 `root`，则以最顶层 id 对应节点作为根节点。

```pseudocode
function register(params):
    idPath = params.idString              # e.g., "main|task|daily"
    idList = split(idPath, "|")           # ["main", "task", "daily"]
    childNode = null                      # 上一个构建的节点（初始为 null）

    # 从叶子节点开始向上构建
    for i from end of idList to start:
        id = idList[i]
        
        if redPointNodeMap contains id:
            # 节点已存在，不需要继续向上构建
            break
            
        newNode = createRedPointNode(id, idPath)

        if childNode is not null:
            newNode.addChild(childNode)
            childNode.setParent(newNode)

        redPointNodeMap[id] = newNode
        childNode = newNode               # 本轮构造的节点将作为下一轮的 child

    # 设置根节点（如果还没有）
    if root is null:
        root = redPointNodeMap[ idList[0] ]

    # 叶子节点设置更新方法
    leafId = idList[-1]                   # 最后一个 ID
    redPointNodeMap[leafId].setUpdateFunc(params.updateFunc)

```



红点树向`RedPointManager`提供接口来注册和删除红点，同时保存红点`id`到`RedPointStruct`的映射

红点树构造方法一般为自根向叶子构造，优化为自叶子向根构造



## 3. `RedPointStruct`

<img src="./图片/RedPointStruct.png" alt="RedPointStruct的结构" style="zoom:80%;" />

上图描述了`RedPointStruct`的基本结构和方法，下面将详细描述一些重要的数据和方法。

### 构造方法

**必要参数**

在`ctor`方法中，`id`和`idString`是构造`RedPointStruct`的必要参数。`idString`是在注册红点树时传入的，在构造红点树的过程中会解析`idString`生成`id`。

**可选参数**

`updateFuncMap`（`key`为`RedPointType`，`value`为`funcList`）是可选参数。在实现中并未强制要求叶子红点有刷新方法，但在业务开发中，必须设置刷新方法，否则这个红点就没有意义了，所以叶子红点这个参数是必需的。对于非叶子红点，这个参数才是可选的。

### 内部数据

**`dirtyMap`**

`dirtyMap`保存了`RedPointStruct`到是否为脏(`bool`)的映射。设置脏标的主要目的是减少不必要的计算。因为红点树作为保存红点的数据结构，在游戏开始时就创建出来了，但是实际要求显示的红点可能并不存在，所以计算红点的显示数据会浪费不必要的性能。使用`dirtyMap`后，在事件触发时对影响到的红点设置脏标，在需要实际计算时，只有有脏标的才进行计算，大大减少了不必要的计算。

**`isShowMap`**

保存实际计算后的红点数据，`key`为`RedPointType`。

**`children`&`parent`**

顾名思义，保存当前红点的子红点（`list`）和父红点，实现父子之间的双向链接。



每一个红点是否都需要有刷新方法？

叶子红点必须有刷新方法，否则没有意义。非叶红点可以没有刷新方法（通过子红点来进行刷新）。当非叶红点有刷新方法时，需要确定刷新方法的优先级。



## 4. 红点问题检查工具

TODO

## 5. 红点树预构建工具



# 需要明确的需求

父红点的显示类型的决定因素：

1. 唯一确定的（比如，即使子红点是数字红点，但父红点仍然显示为红点）
2. 由子红点决定（这种情况下子红点和父红点的显示类型应当一致）
3. 由显示优先级决定（可拓展性高，多个点亮的子红点可以根据显示优先级影响父红点的显示）

父红点是否需要红点条件：应该是需要的，需要思考一种管理方式

红点结构的生成方式：

1. 预先配置生成。策划预先定义好红点结构，客户端注册逻辑红点结构.
2. 客户端在代码编写过程中自行注册，需要妥善管理好树型结构（注册到树中、注册到父红点）
   直接注册到父红点中需要判断父红点是否存在（通过红点唯一Id判断）

# 性能优化

1. 延迟刷新

当事件触发时，只有红点`UI`有效的红点才进行逻辑刷新，否则只设置脏标。是否可以在游戏空闲帧进行一次统一刷新？

2. 红点整合

有些红点其实刷新逻辑和显示逻辑是相同的（比如有不同的可完成任务，策划希望用不同的红点来表示，但内部逻辑都是一样的），只是显示的`UI`有差异，可以归为一类

3. 如果一个非叶结点的子红点全都没了，且没有刷新方法，这个红点就没有意义了，应该从红点树中取消注册
4. 如果一个分类下有很多性质类似的子红点，比如背包，如何减少红点树占用的内存呢？现在让父结点有刷新方法或许可以解决。

# 仍留疑问

1. 某个非叶子结点变化了如何刷新（UI有效）？
   如果该结点的`showNum>0`则不对子红点进行遍历（脏标仍然为`false`），否则需要遍历，
2. 如果有需求是希望红点用特别的符号代表，比如说聊天红点希望用最新一条记录的头像这种怎么处理？
   新增的自定义红点，`ctor`时需要传入方法，单独处理？
3. 