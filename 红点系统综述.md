# 红点系统综述



## 红点的结构

红点主要分为以下两种结构：

### 1. 树型红点

这种红点主要符合游戏的界面层级结构，子红点的显示逻辑独立，同一层级的子红点以或关系影响父红点的显示（穿透）。

### 2. 独立红点

这种红点主要用于一些不穿透的独立红点，它们的显示不会影响上一级界面。



## 红点的类型

### 1. new红点

一般用于新功能开启或者获得新道具时，消失方式为点击后消失，客户端存储点击状态。

### 2. 普通红点

最常见的红点，一般用于玩法可玩、道具可用或其他策划希望玩家点击的功能，点击不会消失，需要满足一定条件（如没有使用次数等）后消失，更新方式一般是玩家操作后的服务器消息回调。

### 3. 数字红点

一般用于玩法次数有限，提示玩家需要消耗，每次使用后数字红点会减少1，剩余次数为0红点消失。

### 4. 自定义红点

为一些玩法特设的红点，逻辑可能和以上任意一种相同，但是表现不同。比如，策划可以要求有新的道具到包使用绿色感叹号，或者有新任务使用黄色感叹（逻辑同2）号。



# 红点系统结构

## 1. `RedPointManager`

整个红点系统由`RedPointManager`统一管理，提供对外接口来管理红点。`RedPointManager`主要包含三部分：红点森林、红点`UI`的`Map`和事件观察者（`eventObserver`）。这样设计的主要目的，是可以把逻辑、`UI`和事件相互隔离，避免耦合。

**为什么采用红点森林？**

因为在开发过程中，可能会遇到策划需要红点不进行穿透（自定义红点穿透），这种情况下，子红点的显示就不应该影响父红点的显示。红点森林包含多棵红点树，每棵红点树作为一个独立的结构进行逻辑管理。

**红点`UI`如何关联到逻辑红点？**

1. 在业务逻辑开发中，红点`UI`通过`id`绑定到逻辑红点。
2. 事件到来时，事件观察者找到事件对应的逻辑红点。
3. 逻辑红点进行刷新，并设置红点`UI`的显示。

**红点`UI`的绑定时机？**

在进入红点所在界面的时候进行绑定，在离开该界面需要对红点进行解绑。

**红点`UI`的刷新流程？**

1. 事件通知`RedPointManager`，`RedPointManager`在森林中找到相应的`RedPointTree`，然后找到对应的那个红点
2. 向根节点设置脏标，逻辑上，但不进行逻辑判断
3. 如果该红点`UI`注册在`RedPointManager`中，则调用对应红点的刷新方法（向叶子红点递归地计算红点），刷新红点的显示，重置脏标

**如果是其中的某个非叶子结点需要刷新该怎么处理？**

先判断自身的刷新函数，本身为`true`则不再对子红点进行遍历，脏标设置为false：
情况①：子红点又因为事件发生了变化，则该红点仍然会被设置脏标；
情况②：该红点因为事件改变，本身需要设置脏标；
优先级不会产生问题，因为是通过红点map进行管理的，所以不同类型的红点会有独立的脏标
问题1：在何时进行优先级判断
暂时考虑在`UI`刷新中，根据该红点注册的红点类型，按优先级判断，所以在`RedPointStruct:isShow()`中只对某个类型的显示与否进行判断。
问题2：`customData`怎么处理?
留给刷新方法自己获取

## 2. `RedPointTree`

红点树实现为一棵字典树，通过红点层级结构进行建树，如果层级路径上有逻辑红点尚未定义，也会递归地进行生成。

红点树向`RedPointManager`提供接口来注册和删除红点，同时保存红点`id`到`RedPointStruct`的映射

红点树构造方法一般为自根向叶子构造，优化为自叶子向根构造



## 3. `RedPointStruct`

每一个红点是否都需要有刷新方法？

叶子红点必须有刷新方法，否则没有意义。非叶红点可以没有刷新方法（通过子红点来进行刷新）。当非叶红点有刷新方法时，需要确定刷新方法的优先级。

```pseudocode
RedPointStruct {
	// 必需属性
	required number id					// 红点唯一id，可通过idString生成
	required string idString			// 红点层级字符串：描述在字典树中的路径
	
	// 可选属性
	optional function updateFuncMap		// 根据红点类型存储刷新方法
	
	// 红点自己维护的属性
	RedPointStruct parent		// 父红点
	RedPointStrcut[] children	// 子红点map，保存一个引用
	boolean[] dirtyMap			// 红点类型->脏标
	
	// 方法
	addChild(RedPointStruct)			// 向RedPointTree暴露接口，用于注册红点时添加子红点
	removeChild(number)					// 移除红点
	isShow(param, type)					// 向RedPointManager暴露接口，判断UI是否显示
	setDirty(boolean, type)				// 向上递归设置脏标
	
}
```

## 4. 红点问题检查工具

TODO



# 需要明确的需求

父红点的显示类型的决定因素：

1. 唯一确定的（比如，即使子红点是数字红点，但父红点仍然显示为红点）
2. 由子红点决定（这种情况下子红点和父红点的显示类型应当一致）
3. 由显示优先级决定（可拓展性高，多个点亮的子红点可以根据显示优先级影响父红点的显示）

父红点是否需要红点条件：应该是需要的，需要思考一种管理方式

红点结构的生成方式：

1. 预先配置生成。策划预先定义好红点结构，客户端注册逻辑红点结构.
2. 客户端在代码编写过程中自行注册，需要妥善管理好树型结构（注册到树中、注册到父红点）
   直接注册到父红点中需要判断父红点是否存在（通过红点唯一Id判断）

# 性能优化

延迟刷新

当事件触发时，只有红点`UI`有效的红点才进行逻辑刷新，否则只设置脏标。

# 仍留疑问

1. 某个非叶子结点变化了如何刷新（UI有效）？
   如果该结点的`showNum>0`则不对子红点进行遍历（脏标仍然为`false`），否则需要遍历，